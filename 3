import pytest
from recommenders.test import load_dataset
from automata_learning import generate_automata_from_dataset, generate_single_accepting_sequence_dfa, run_automata
from trace_alignment import augment_constraint_automata, augment_trace_automata, create_intersection_automata, run_trace_alignment

@pytest.fixture
def dataset():
    return load_dataset(load_path="saved/counterfactual_dataset.pickle") 

@pytest.fixture
def original_trace(dataset):
    gp, _ = dataset
    original_trace = gp[0][0].tolist()
    return original_trace

@pytest.fixture
def t_dfa(original_trace):
    t_dfa = generate_single_accepting_sequence_dfa(original_trace)
    return t_dfa

@pytest.fixture
def a_dfa(original_trace):
    t_dfa = generate_single_accepting_sequence_dfa(original_trace)
    return t_dfa

@pytest.fixture
def t_dfa_aug(t_dfa):
    return augment_trace_automata(t_dfa)

@pytest.fixture
def a_dfa_aug(a_dfa, t_dfa):
    return augment_constraint_automata(a_dfa, t_dfa)

def test_augmented_trace_automata(t_dfa, t_dfa_aug, original_trace):
    t_dfa_accepts = run_automata(t_dfa, original_trace)
    assert t_dfa_accepts

    gp_edit = original_trace.copy()
    edit_item = gp_edit[10]
    gp_edit[10] = f"del_{edit_item}"
    # gp_edit.insert(11, f"add_{edit_item}")

    t_dfa_aug_accepts = run_automata(t_dfa_aug, gp_edit)
    assert t_dfa_aug_accepts


@pytest.mark.skip()
def test_augmented_constraint_automata(a_dfa, a_dfa_aug, original_trace): 
    # Test if automata is built correctly
    # a_dfa should accept points from the good_points and reject points from bad_points
    a_dfa_accepts = run_automata(a_dfa, original_trace)
    assert a_dfa_accepts, "A_DFA rejected good point"

    # a_dfa_aug should accept points from good_points that have been edited
    # with add_p and del_p propositions, and rejecting bad_points that have
    # been edited with add_p and del_p propositions

    #Remove and add the same item, so the point accepted before the edits should be accepted again by the
    #augmented automaton
    gp_edit = original_trace.copy()
    edit_item = gp_edit[10]
    gp_edit[10] = f"del_{edit_item}"
    gp_edit.insert(11, f"add_{edit_item}")
    print("gp", original_trace)
    print("gp edited", gp_edit)
    a_dfa_accepts = run_automata(a_dfa_aug, gp_edit)
    assert a_dfa_accepts, "A_DFA rejected edited good point"


@pytest.mark.skip()
def test_create_planning_automata(a_dfa_aug, t_dfa_aug, original_trace):
    planning_dfa = create_intersection_automata(a_dfa_aug, t_dfa_aug)

    a_dfa_aug_accepts = run_automata(a_dfa_aug, original_trace)
    t_dfa_aug_accepts = run_automata(t_dfa_aug, original_trace)
    planning_dfa_accepts = run_automata(planning_dfa, original_trace)

    assert a_dfa_aug_accepts and t_dfa_aug_accepts and planning_dfa_accepts, f"""
    DFA are not accepting good input
        a_dfa_aug_accepts: {a_dfa_aug_accepts}
        t_dfa_aug_accepts: {t_dfa_aug_accepts}
        planning_dfa_accepts: {planning_dfa_accepts}
    """
    gp_edit = original_trace.copy()
    edit_item = gp_edit[10]
    gp_edit[10] = f"del_{edit_item}"
    gp_edit.insert(11, f"add_{edit_item}")
    t_dfa_aug_accepts = run_automata(t_dfa_aug, gp_edit)
    a_dfa_aug_accepts = run_automata(a_dfa_aug, gp_edit)
    planning_dfa_accepts = run_automata(planning_dfa, gp_edit)

    assert a_dfa_aug_accepts and t_dfa_aug_accepts and planning_dfa_accepts, f"""
    DFA are not accepting edited good input
        a_dfa_aug_accepts: {a_dfa_aug_accepts}
        t_dfa_aug_accepts: {t_dfa_aug_accepts}
        planning_dfa_accepts: {planning_dfa_accepts}
    """
    print("Planning DFA alphabet:", planning_dfa.get_input_alphabet())

@pytest.mark.skip(f"Running only when {test_create_planning_automata.__name__} will work")
def test_run_trace_alignment(a_dfa_aug, t_dfa_aug, original_trace):
    planning_dfa = create_intersection_automata(a_dfa_aug, t_dfa_aug)
    
    print(f"{test_run_trace_alignment.__name__}: Desired trace: ", original_trace)
    original_trace[10], original_trace[20] = original_trace[20], original_trace[10]
    print(f"{test_run_trace_alignment.__name__}: Modified trace: ", original_trace)
    alignment = run_trace_alignment(planning_dfa, original_trace)
    alignment = {x: len(x) for x in alignment}
    if len(alignment) == 0:
        print("No alignment found")
        return
    alignment = sorted(alignment.items(), key=lambda x: alignment[x[0]])
    print("Best alignment", alignment[0])
    assert alignment[0][1] == 2


    

    
