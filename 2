from deap import base, creator, tools, algorithms
import numpy as np
import random
import torch
from tqdm import tqdm
from abc import ABC, abstractmethod
from typing import List, Tuple, Callable
import torch.nn.functional as F
from enum import Enum

class NumItems(Enum):
    ML_100K=1682
    ML_1M= 3952 - 500

def edit_distance(seq1, seq2):
    return 1 - np.sum(np.array(seq1) == np.array(seq2)) / len(seq1)  # Fraction of matching elements

def cosine_distance(prob1: torch.Tensor, prob2: torch.Tensor) -> float:
    return 1 - F.cosine_similarity(prob1, prob2, dim=-1).item()

def self_indicator(seq1, seq2):
    return float("inf") if (seq1 == seq2).all() else 0

def dummy_model(seq: torch.Tensor) -> torch.Tensor:
    #NOTE: dummy black box model
    return torch.randn((1, 1983))


def random_points_with_offset(max_value: int, max_offset: int):
    i = random.randint(1, max_value - 1)
    j = random.randint(max(0, i - max_offset), min(max_value - 1, i + max_offset))
    # Sort i and j to ensure i <= j
    return tuple(sorted([i, j]))

def mutate(seq: List[int], indpb: float):
    if random.random() > indpb:
        return
    mutation = random.choice([mutate_replace, mutate_swap])
    return mutation(seq)

def mutate_replace(seq, max_value:NumItems=NumItems.ML_1M, num_replaces:int=1):
    for _ in range(num_replaces):
        i = random.sample(range(len(seq)), 1)[0]
        new_value = random.randint(1, max_value.value)
        seq[i] = new_value
    return torch.tensor(seq)

def mutate_swap(seq: List[int], offset_ratio: float=0.8):
    # seq = sequence.clone().squeeze(0).tolist()
    max_offset = round(len(seq) * offset_ratio)
    i, j = random_points_with_offset(len(seq)-1, max_offset)
    seq[i], seq[j] = seq[j], seq[i]
    return torch.tensor(seq)

class GeneticGenerationStrategy():
    def __init__(self, input_seq: torch.Tensor, predictor: Callable, pop_size: int=1000, generations: int=20, good_examples: bool=True):
        self.input_seq = input_seq
        self.predictor = predictor
        self.pop_size = pop_size
        self.gt = self.predictor(input_seq)
        self.generations = generations
        self.good_examples = good_examples
        # Define the evaluation function
        creator.create("fitness", base.Fitness, weights=(-1.0,))  # Minimize fitness
        creator.create("individual", list, fitness=creator.fitness)
        
        self.toolbox = base.Toolbox()
        self.toolbox.register("feature_values", lambda x: x.tolist(), input_seq)
        self.toolbox.register("individual", tools.initIterate, creator.individual, self.toolbox.feature_values)
        self.toolbox.register("population", tools.initRepeat, list, self.toolbox.individual, n=self.pop_size)

        self.toolbox.register("evaluate", self.evaluate_fitness)
        self.toolbox.register("mate", tools.cxTwoPoint)  # Use two-point crossover
        self.toolbox.register("mutate", mutate, indpb=0.05)  # Flip mutation for simplicity
        self.toolbox.register("select", tools.selTournament, tournsize=3)  # Tournament selection
    
    def evaluate_fitness(self,individual):
        ALPHA1= 0.5
        ALPHA2 = 1 - ALPHA1
        candidate_seq = torch.tensor(individual)
        candidate_prob = self.predictor(candidate_seq)  # Function to assign label based on the recommender system
        seq_dist = edit_distance(self.input_seq, candidate_seq) #[0,1]
        label_dist = cosine_distance(self.gt, candidate_prob) #[0,1]
        self_ind = self_indicator(self.input_seq, candidate_seq) #0 if different, inf if equal
        if not self.good_examples:
            label_dist = 1 - label_dist
        return ALPHA1 * seq_dist + ALPHA2 * label_dist + self_ind,

    def genetic_algorithm(self):
        population = self.toolbox.population(n=self.pop_size)

        for gen in tqdm(range(self.generations), "Genetic algorithm..."):
            # Evaluate the individuals with the objective function
            fitnesses = [self.toolbox.evaluate(ind) for ind in population]
            for ind, fit in zip(population, fitnesses):
                ind.fitness.values = fit
            
            # Select the next generation individuals
            offspring = self.toolbox.select(population, len(population))
            offspring = list(map(self.toolbox.clone, offspring))

            # Apply crossover and mutation on the offspring
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                if random.random() < 0.7:  # Crossover probability
                    self.toolbox.mate(child1, child2)
                    # del child1.fitness.values
                    # del child2.fitness.values

            for mutant in offspring:
                mutant_c = toolbox.clone(mutant)
                if random.random() < 0.2:  # Mutation probability
                    self.toolbox.mutate(mutant_c)
                    # del mutant.fitness.values
            
            # Replace the old population by the offspring
            population[:] = offspring

        population = [(torch.tensor(x), self.predictor(torch.tensor(x)).argmax(-1).item()) for x in population]
        label_eval, seq_eval = self.evaluate_generation(population)
        print(f"Good examples = {self.good_examples} ratio of same_label is: {label_eval*100}%, avg distance: {seq_eval}")
        return population

    def generate(self):
        best_example = self.genetic_algorithm()
        return best_example

    def evaluate_generation(self, examples):
        # Evaluate label
        label = self.gt.argmax(-1).item()
        same_label = sum(1 for ex in examples if ex[1] == label)
        # Evaluate example similarity
        distances = []
        for seq, _ in examples:
            distances.append(edit_distance(self.input_seq, seq))
        return (same_label / len(examples)), (sum(distances)/len(distances))

# def generate(strategy: GeneticGenerationStrategy):
#     src = np.random.randint(0, 100, (20,))
#     best_example = strategy.generate(src, dummy_model)
#     print([ex.item() for ex in best_example])

if __name__ == "__main__":
    x = torch.randint(0, NumItems.ML_1M.value, (50,))
    result = GeneticGenerationStrategy(x, predictor=dummy_model).generate()
    print(result)
